a user address user@host 'has remoteStorage' if:

personal web services is supported for user@host, with at least one of the following discovery mechanisms
MUST webfinger
MAY http instead of https for the host-meta
MAYNOT single-origin for the host-meta
MAY xrd instead of jrd for the host-meta
MAY host-meta on host-meta.json instead of host-meta (does that comply with both host-meta and webfinger spec?)
MAY http instead of https for the lrdd
MAYNOT single-origin for the lrdd
MAYNOT 11.04 format
MAY 11.10 format
MAY 12.04 format

MUST OAuth2-implicit-grant
MAYNOT ? instead of #
MAY include scope feedback

core "unhosted apps + user-hosted service" spec
  - unhosted app means an application that runs in the browser, with no server-side code. the app's statics are hosted, but its execution is not. it's synonymous to client-side app, and to html5 app.
  - user-hosted service is a relative term - the service itself /is/ hosted somewhere, but it is dynamically linked to the unhosted app, independent of the app, but dependent on the user. The identity-confirmation service provided by an IdP in protocols like OpenID, BrowserID, and SAML is example of a user-hosted service (although the RP is not usually an unhosted app in any of those examples).
  - recognized user-hosted service (or "service"): a user-hosted service that is described on either our 'stable' or our 'experimental' short-list. Both lists are maintained by the Unhosted W3C CG, as is this spec.
  - recognized discovery mechanism: a discovery mechanism that is described on either our 'stable' or our 'experimental' short-list. Both lists are maintained by the Unhosted W3C CG, as is this spec.
  - recognized auth mechanism: an auth mechanism that is described on either our 'stable' or our 'experimental' short-list. Both lists are maintained by the Unhosted W3C CG, as is this spec.
  - server: an http service that offers at least one user-hosted service for at least one user, plus at least one of our discovery mechanisms, and at least one of our auth mechanisms, in such a way that the 3 work together, i.e., all its services are discoverable through all its discovery mechanisms, and can be authed through all its auth mechanisms.
  - even if, through redirects there are many different and even unrelated pysical servers involved in offering the combination of discovery, auth and service, we still call it one server. for instance, maybe your discovery and for instance your storage are served by unrelated companies, you just made one point to the other, we still model that as one server.
  - setting:
    - user brings: [web app identifier, server identifier, user identifier, sufficient credentials for user@server]
    - device: lets the user
    - user interface: lets the user interact with the device
    - device: ties together user interface, runtime, http client, chrome.
    - app: an unhosted app
    - api: lets the app interact with the user and the server.
    - chrome: any interface for the user to interact with, that is neiher part of the app, nor of the server interface
    - interactions:user interaction (device OS), app interaction (html5), service interaction (http, html5)
  - discovery mechanism
      -> a self-explanatory interaction of user-browser, user-app, browser-service, app-service, and user-service, that results in the app knowing which services are available
  - auth mechanism
      -> a self-explanatory interaction of user-browser, user-app, browser-service, app-service, and user-service, that results in the app having access to the services which the user wants it to have access to.
  - service
      -> something that can go on http+cors, or WebSocket, or JSONP, or outgoing GET, or some other cross-domain way for the app to communicate with something dynamically linked.
- since most current user agents don't implement any of this, usually the 'user-agent' role is folded into the 'unhosted app' role, using an "unhosted app player" js library

service record in lrdd has:
  - id (so that the user may recognise which one it is)
  - type (functionality)
  - caps (parameterizes type)
  - details (how to contact it)
  - params (parameterizes session)

generic part version 1: lib-with-app:
-start with user[user identifier, server identifier, credentials, app identifier], and agent
user->agent: app identifier
-add appserver[app code, lib code[controller code, discoverer code, auther code, client code]
appserver->agent: app code, lib code
-add app[app code], controller[controller code], discoverer[discoverer code], auther[auther code], client[client code]
app->user: start screen
controller->user: login box
(disco)
(auth)
(access)

generic part version 2: post-PC:
-start with user[user identifier, server identifier, credentials, app identifier], agent, controller[controller code], discoverer[discoverer code], auther[auther code], client[client code]
controller->user: login box
user->controller: user identifier, server identifier, credentials
(disco)
-add app[app code]
app->user: start screen
(auth)
(access)

(disco):
user->controller: user identifier, server identifier
-foreach discovery mechanism:
  controller->discoverer: discovery mechanism, user identifier, server identifier
  ...(discoverer does its mechanism-specific thing)
  -if successful:
    discoverer->controller:services(list(service id, type, caps & details, list(auth mechanism id, type, caps & details)))
  -if not:
    discoverer->controller:NACK
controller->app:grand total of (service id, type, caps) combinations discovered.

(auth):
app->controller:requested[list(service id, service params)]
-foreach different auth option occuring in at least one service in requested
  controller->user:auth mechanism id (don't know if this makes sense, let's say this is optional info to display to the user)
  controller->auther:auth mechanism type, caps, details, list(service type, caps, params)
  ...(auther does its mechanism-specific thing)
  -if successful:
    auther->controller:list of service type, caps, params, credentials, status ('should work' or 'might work')
  -if not:
    auther->controller:NACK
controller->app:grand total list of service id, type, caps, params, status ('should work' or 'might work')

(access):
-foreach action:
  app->controller: service id, action, action params
  controller->client: service id, type, caps, details, params, status, action, action params, credentials
  ..(client does its service- and client-specific thing)
  client->controller:result
  controller->app:result

discovery mechanism 'webfinger-based':
controller->discoverer: user identifier, server identifier
-add server[host-meta, map(user identifier->lrdd)]
server->discoverer: host-meta
discoverer->server: user identifier
server->discoverer: user's lrdd
-if successful:
  discoverer->controller:services(list(service type, service caps, service details, list(auth mechanism type, auth mechanism details)))
-if not:
  discoverer->controller:NACK

auth mechanism OAuth-based:
-start with user[user identifier, server identifier, credentials, app identifier], agent, app[app code[scopes], service types], auther[auther code, user identifier, server identifier, auth mechanism params:[popupPath]]
controller->auther:auth mechanism type, caps, details, list(service type, caps, params)
auther->agent: popupUrl[server identifier, popupPath, scopes]
agent->server: popupUrl[server identifier, popupPath, scopes]
server->agent: dialog code
-add dialog[dialog code]
dialog->user: start screen
user->dialog: decision
dialog->server:decision
-if successful:
  server->agent:token
  agent->auther:token
  auther->controller:list of service type, caps, params, credentials, status ('should work' or 'might work')
-if not:
  server->agent:NACK
  agent->auther:NACK
  auther->controller:NACK
  controller->app:NACK
app-initiated service access:
app[app code[scopes], service types], lib[libcode[map(service type, action, actionParams->requestType, requestParams, map(responseParams->result))],lrdd,token]
app->controller: service id, action, action params
controller->client: service id, type, caps, details, params, status, action, action params, credentials
client->server:requestType,requestParams, credentials
server->client:responseParams
client->controller:result
controller->app:result
app->lib:service type, action, actionParams
lib->app:result

for now, we're modelling server-initiated and bidirectional services and app-to-app services all as if they were app-initiated services, using for instance the 'callback' pattern like the one often used in javascript.

A: the action.
B: the login. (may start earlier)
C: the connection.
D: the decision.
E: the grant.
F: reuse.
G: revokation.


A: the action.
Notice that B and part of C may already happen before, or in parallel, so the app may have an indication of whether the action will succeed. This may influence steps 2, 3 and 4. We model those connections in our 'interaction design' spec.

The first step establishes a session involving the user, the user-agent, and the app:
A1) user->user-agent:
  -app id
It could be omitted in case the app was pre-installed with the device, in which case this step becomes implicit in the gesture of powering on a device in the first place.

A2) app->user:(optional)
  -invitation to action
the app may display a button or an input field for instance.

A3)user->app:(optional)
  -intention gesture
the user tells the app to take a certain action which will involve one of the user's personal data services.

A4) app->client:
  -service type
  -scope
  -action
the app tells teh client what it wants. presumably the app knows what type of service could complete the desired action, and what access scope would be necessary to convince the server to do that. We could define actions where the client decides how to complete them, but for now we haven't done that, because it's all alot more straightforward this way.

A5) client->connector:
  -service type
  -scope
the client will be able to execute the action, but doesn't have credentials for this scope at any service of this type at this point. so it asks the connector. That's where we go to step C: the connection. But before the connector is ready for that, it first need to go through B, the login, with the user.

the app may exaggerate the scope to pre-authorize future actions, and avoid the user being annoyed by small decisions every 5 seconds. In an extreme case (which remoteStorage implements), the first action may be NOOP, so that effectively it's just a login flow (see also 'interaction design' spec).

B: the login.
B1) connector->user:(optional)
  -login prompt
B2) user->connector:
  -user id
  -server id
  (-server credentials)
Already giving the server credentials at this point is optional, this can also be delayed until D (the decision).

C: discovery.
this step is optional if you already know there will be no more than 1 choice matching the
C1) connector->server:(through some redirections)
  -service type, scope
C2) server->connector:
  -service details,
  -service label,
  -service caps,

Once A and B are complete, the connector has:
  -server id
  -user id
  -server credentials
  -requested service type
  -requested scope
  -requested action

There will probably be some interaction where it first sends the userid, receives some pointers, including maybe already the server details and available scopes, followed later by the specific request.

D) CHOICE
it's also possible that multiple services are discovered, in which case there might be another interaction between connector and user.
D1) connector->user: (only if the server responded with multiple options)
  -service names
D2) user-> connector:
  -
D: the decision.
D1) server->user:
  -question
D2) user->server:
  -answer
  (-user credentials)
If no user credentials were given yet in step B, and passed in step C, then the user can still give them directly in this step.


E: the access.
E1)server->client:
  -token

Steps and substeps with a * are obligatory, all the others may be skipped.

Sequence:
[(((A&B) C (D|)) & E) (F|) (G|) ( Ha [(Hb(G|))]* (Hc|Hd|He|) |)]*

myfavouritesandwich:
[ E2,B,A,C2,E1 | B,A,C2,E1,E2 ] E3,Ga1, [Gb4,F1]*, [ Gd1,Gd4 | ] Ge1,Ge2

Note that we're actually doing step Gd wrong. the session cannot be considered to have ended until it has ended on the server, unless the client is trusted, which in general it is not. even if the app and the server are in the same trust zone, it's better for the server to not rely on the client for session end).

idea for spec: implement


A*: HELLO
A1) connector->user: login prompt
A2*) user->connector: user id, server id

B*: INTENT:
B1) user->user-agent: app id
B2) app->user: invitation to action
B3) user->app: intention gesture
B4*) app->client:service type, scope, action
B5*) client->connector: service type, scope, action

C*: DISCOVERY
C1) connector->server: service type, scope
C2*) server->connector: service details, service label, service caps,

D) CHOICE
D1) connector->user: service labels
D2*) user-> connector: service label of choice

E) INSTRUCTION
E1) server->user: question
E2*) user->server: user credentials
E3) user->server: answer

F) FEEDBACK
F1) server->client: response

Ga) SESSION START
Ga1*) server->client: token

Gb: SESSION ACTION:
Gb1) app->user: invitation to action
Gb2) user->app: intention gesture
Gb3) app->client: action
Gb4*) client->server: action, token

Gc: CONNECTOR-MEDIATED REVOKATION (FIXME: implement Gc2,Gc3,Gc5 in remoteStorage)
Gc1*) user->connector: request to end session
Gc2*) connector->server: request to end session
Gc3*) server->connector: confirmation of session end
Gc4) connector->client: request to end session
Gc5) connector->user: confirmation of session end

Ge: SERVER-SIDE REVOKATION
Ge1) user->server: request to end session
Ge2) server->user: confirmation of session end
Ge3) server->client: notification of session end
