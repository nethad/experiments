
core "unhosted apps + user-hosted service" spec
  - unhosted app means an application that runs in the browser, with no server-side code. the app's statics are hosted, but its execution is not. it's synonymous to client-side app, and to html5 app.
  - user-hosted service is a relative term - the service itself /is/ hosted somewhere, but it is dynamically linked to the unhosted app, independent of the app, but dependent on the user. The identity-confirmation service provided by an IdP in protocols like OpenID, BrowserID, and SAML is example of a user-hosted service (although the RP is not usually an unhosted app in any of those examples).
  - recognized user-hosted service (or "service"): a user-hosted service that is described on either our 'stable' or our 'experimental' short-list. Both lists are maintained by the Unhosted W3C CG, as is this spec.
  - recognized discovery mechanism: a discovery mechanism that is described on either our 'stable' or our 'experimental' short-list. Both lists are maintained by the Unhosted W3C CG, as is this spec.
  - recognized auth mechanism: an auth mechanism that is described on either our 'stable' or our 'experimental' short-list. Both lists are maintained by the Unhosted W3C CG, as is this spec.
  - server: an http service that offers at least one user-hosted service for at least one user, plus at least one of our discovery mechanisms, and at least one of our auth mechanisms, in such a way that the 3 work together, i.e., all its services are discoverable through all its discovery mechanisms, and can be authed through all its auth mechanisms.
  - even if, through redirects there are many different and even unrelated pysical servers involved in offering the combination of discovery, auth and service, we still call it one server. for instance, maybe your discovery and for instance your storage are served by unrelated companies, you just made one point to the other, we still model that as one server.
  - setting:
    - user brings: [web app identifier, server identifier, user identifier, sufficient credentials for user@server]
    - device: lets the user
    - user interface: lets the user interact with the device
    - device: ties together user interface, runtime, http client, chrome.
    - app: an unhosted app
    - api: lets the app interact with the user and the server.
    - chrome: any interface for the user to interact with, that is neiher part of the app, nor of the server interface
    - interactions:user interaction (device OS), app interaction (html5), service interaction (http, html5)
  - discovery mechanism
      -> a self-explanatory interaction of user-browser, user-app, browser-service, app-service, and user-service, that results in the app knowing which services are available
  - auth mechanism
      -> a self-explanatory interaction of user-browser, user-app, browser-service, app-service, and user-service, that results in the app having access to the services which the user wants it to have access to.
  - service
      -> something that can go on http+cors, or WebSocket, or JSONP, or outgoing GET, or some other cross-domain way for the app to communicate with something dynamically linked.
- since most current user agents don't implement any of this, usually the 'user-agent' role is folded into the 'unhosted app' role, using an "unhosted app player" js library

service record in lrdd has:
  - id (so that the user may recognise which one it is)
  - type (functionality)
  - caps (parameterizes type)
  - details (how to contact it)
  - params (parameterizes session)

generic part version 1: lib-with-app:
-start with user[user identifier, server identifier, credentials, app identifier], and agent
user->agent: app identifier
-add appserver[app code, lib code[controller code, discoverer code, auther code, client code]
appserver->agent: app code, lib code
-add app[app code], controller[controller code], discoverer[discoverer code], auther[auther code], client[client code]
app->user: start screen
controller->user: login box

generic disco-then-auth flow:
user->controller: user identifier, server identifier
-foreach discovery mechanism:
  controller->discoverer: discovery mechanism, user identifier, server identifier
  ...
  -if successful:
    discoverer->controller:services(list(service id, type, caps & details, list(auth mechanism id, type, caps & details)))
  -if not:
    discoverer->controller:NACK
controller->app:grand total of (service id, type, caps) combinations discovered.
app->controller:requested[list(service id, service params)]
-foreach different auth option occuring in at least one service in requested
  controller->user:auth mechanism id (don't know if this makes sense, let's say this is optional info to display to the user)
  controller->auther:auth mechanism type, caps, details, list(service type, caps, params)
  ...
  -if successful:
    auther->controller:list of service type, caps, params, credentials, status ('should work' or 'might work')
  -if not:
    auther->controller:NACK
controller->app:grand total list of service id, type, caps, params, status ('should work' or 'might work')
-foreach action:
  app->controller: service id, action, action params
  controller->client: service id, type, caps, details, params, status, action, action params, credentials
  ..
  client->controller:result
  controller->app:result

discovery mechanism 'webfinger-based':
controller->discoverer: user identifier, server identifier
-add server[host-meta, map(user identifier->lrdd)]
server->discoverer: host-meta
discoverer->server: user identifier
server->discoverer: user's lrdd
-if successful:
  discoverer->controller:services(list(service type, service caps, service details, list(auth mechanism type, auth mechanism details)))
-if not:
  discoverer->controller:NACK

auth mechanism OAuth-based:
-start with user[user identifier, server identifier, credentials, app identifier], agent, app[app code[scopes], service types], auther[auther code, user identifier, server identifier, auth mechanism params:[popupPath]]
controller->auther:auth mechanism type, caps, details, list(service type, caps, params)
auther->agent: popupUrl[server identifier, popupPath, scopes]
agent->server: popupUrl[server identifier, popupPath, scopes]
server->agent: dialog code
-add dialog[dialog code]
dialog->user: start screen
user->dialog: decision
dialog->server:decision
-if successful:
  server->agent:token
  agent->auther:token
  auther->controller:list of service type, caps, params, credentials, status ('should work' or 'might work')
-if not:
  server->agent:NACK
  agent->auther:NACK
  auther->controller:NACK
  controller->app:NACK
app-initiated service access:
app[app code[scopes], service types], lib[libcode[map(service type, action, actionParams->requestType, requestParams, map(responseParams->result))],lrdd,token]
app->controller: service id, action, action params
controller->client: service id, type, caps, details, params, status, action, action params, credentials
client->server:requestType,requestParams, credentials
server->client:responseParams
client->controller:result
controller->app:result
app->lib:service type, action, actionParams
lib->app:result

for now, we're modelling server-initiated and bidirectional services and app-to-app services all as if they were app-initiated services, using for instance the 'callback' pattern like the one often used in javascript.
